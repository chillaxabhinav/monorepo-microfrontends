const path = require('path')
const shell = require('shelljs')
const webpack = require('webpack')
const rimraf = require('rimraf')
const nodemon = require('nodemon')
const webpackConfig = require('../../webpack/config/webpack.config')
const webpackDevMiddleware = require('webpack-dev-middleware')
const webpackHotMiddleware = require('webpack-hot-middleware')
const express = require('express')
const paths = require('../../shared/config/paths')
const { logMessage, compilerPromise } = require('../utils')

const app = express();

const cleanExit = function () {
    process.exit()
}
  
process.on('SIGINT', cleanExit);

process.on('SIGTERM', cleanExit);

const start = async (env, config) => {
    const WEBPACK_PORT = process.env.WEBPACK_PORT;
    rimraf.sync(paths.clientBuild)
    rimraf.sync(paths.serverBuild)

    const [clientConfig, serverConfig] = webpackConfig(env, config)
    const publicPath = clientConfig.output.publicPath

    const multiCompiler = webpack([clientConfig, serverConfig])

    const clientCompiler = multiCompiler.compilers.find(
        (compiler) => compiler.name !== 'server'
    )
    const serverCompiler = multiCompiler.compilers.find((compiler) => compiler.name === 'server')

    const clientPromise = compilerPromise('client', clientCompiler)
    const serverPromise = compilerPromise('server', serverCompiler)

    const watchOptions = {
        // poll: true,
        ignored: /node_modules/,
        aggregateTimeout: 600
    }

    app.use((req, res, next) => {
        res.header('Access-Control-Allow-Origin', '*')
        return next()
    })

    // this serves static files + recompiles client files on new changes
    app.use(
        webpackDevMiddleware(clientCompiler, {
            publicPath: clientConfig.output.publicPath,
            writeToDisk: true,
            stats: clientConfig.stats
        })
    )
    // it syncs the new files generated by devMiddleware to client without manual reload
    app.use(webpackHotMiddleware(clientCompiler));
    app.use(paths.publicPath, express.static(paths.clientBuild));

    const webpackServer = app.listen(WEBPACK_PORT)
    let script;
    // this recompiles server files on new changes
    serverCompiler.watch(watchOptions, (error, stats) => {
        if (!error && stats && !stats.hasErrors()) {

            console.group("\nserver:")
            console.log(stats.toString(serverConfig.stats));
            console.groupEnd();
            // script && script.restart();
            return
        }

        if (error) {
            logMessage(error, 'error')
        }

        if (stats.hasErrors()) {
            const info = stats.toJson()
            logMessage(info.errors[0].message, 'error')
        }
    })
    // wait until client and server is compiled
    try {
        await clientPromise
        await serverPromise
    } catch (error) {
        logMessage(error, 'error')
    }

    script = nodemon(
        {
          env: {
              NODE_ENV: "development"
          },
          delay: 1,
          script: `${paths.serverBuild}/index.js`
        }
      )

    script.on('restart', () => {
      logMessage('Server side app has been restarted.', 'warning')
    })
    
    script.on('quit', () => {
      console.log('Process ended')
      webpackServer.close();
      process.exit()
    })
    
    script.on('error', () => {
      logMessage('An error occured. Exiting', 'error')
      webpackServer.close();
      process.exit(1)
    })
}

const startWithoutSsr = async (env, config) => {
    rimraf.sync(paths.clientBuild);
    
    const [clientConfig, serverConfig] = webpackConfig(env, config)
    const publicPath = clientConfig.output.publicPath

    const clientCompiler = webpack(clientConfig)

    const clientPromise = compilerPromise('client', clientCompiler)

    app.use((req, res, next) => {
        res.header('Access-Control-Allow-Origin', '*')
        return next()
    })

    // this serves static files + recompiles client files on new changes
    app.use(
        webpackDevMiddleware(clientCompiler, {
            publicPath: clientConfig.output.publicPath,
            writeToDisk: true,
            stats: clientConfig.stats
        })
    );

    // it syncs the new files generated by devMiddleware to client without manual reload
    app.use(webpackHotMiddleware(clientCompiler));
    app.use(paths.publicPath, express.static(paths.clientBuild));

    app.get('**', (req, res) => {
        res.sendFile(path.join(paths.clientBuild, 'index.html'))
    })

    // wait until client is compiled
    try {
        await clientPromise
    } catch (error) {
        logMessage(error, 'error')
    }
    const PORT = process.env.PORT;
    app.listen(PORT, () => {
        console.log(`Server running on http://localhost:${PORT}`);
    })
}

module.exports = (env, config) => {
    if (config.ssr) {
        return start(env, config);
    }
    return startWithoutSsr(env, config);
}
